"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_util_1 = require("node:util");
const node_stream_1 = require("node:stream");
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const html_formatter_1 = require("@cucumber/html-formatter");
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const mime_1 = __importDefault(require("mime"));
const messages_1 = require("@cucumber/messages");
exports.default = {
    type: 'formatter',
    formatter({ on, options, write, directory }) {
        if (!directory && options.externalAttachments) {
            throw new Error('Unable to externalise attachments when formatter is not writing to a file');
        }
        const newId = messages_1.IdGenerator.uuid();
        const htmlStream = new html_formatter_1.CucumberHtmlStream((0, resolve_pkg_1.default)('@cucumber/html-formatter', { cwd: __dirname }) +
            '/dist/main.css', (0, resolve_pkg_1.default)('@cucumber/html-formatter', { cwd: __dirname }) +
            '/dist/main.js');
        const writeOperations = [];
        on('message', (message) => {
            if (message.attachment && options.externalAttachments) {
                const { attachment, writeOperation } = externaliseAttachment(newId, message.attachment, directory);
                htmlStream.write({
                    ...message,
                    attachment,
                });
                if (writeOperation) {
                    writeOperations.push(writeOperation);
                }
            }
            else {
                htmlStream.write(message);
            }
        });
        htmlStream.on('data', (chunk) => write(chunk));
        return async () => {
            htmlStream.end();
            await (0, node_util_1.promisify)(node_stream_1.finished)(htmlStream);
            await Promise.all(writeOperations);
        };
    },
    documentation: 'Outputs a HTML report',
    optionsKey: 'html',
};
const alwaysInlinedTypes = ['text/x.cucumber.log+plain', 'text/uri-list'];
const encodingsMap = {
    IDENTITY: 'utf-8',
    BASE64: 'base64',
};
function externaliseAttachment(newId, original, directory) {
    if (alwaysInlinedTypes.includes(original.mediaType)) {
        return { attachment: original };
    }
    let filename = `attachment-${newId()}`;
    const extension = mime_1.default.getExtension(original.mediaType);
    if (extension) {
        filename += `.${extension}`;
    }
    const writeOperation = (0, node_util_1.promisify)(node_fs_1.writeFile)(node_path_1.default.join(directory, filename), Buffer.from(original.body, encodingsMap[original.contentEncoding]));
    const updated = {
        ...original,
        contentEncoding: messages_1.AttachmentContentEncoding.IDENTITY,
        body: '',
        url: `./${filename}`,
    };
    return {
        attachment: updated,
        writeOperation,
    };
}
//# sourceMappingURL=html.js.map