"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTable = void 0;
exports.attach = attach;
exports.isFeature = isFeature;
exports.doesFeatureMatch = doesFeatureMatch;
exports.Given = defineStep;
exports.When = defineStep;
exports.Then = defineStep;
exports.defineStep = defineStep;
exports.Step = runStepDefininition;
exports.defineParameterType = defineParameterType;
exports.Before = defineBefore;
exports.After = defineAfter;
exports.BeforeStep = defineBeforeStep;
exports.AfterStep = defineAfterStep;
exports.BeforeAll = defineBeforeAll;
exports.AfterAll = defineAfterAll;
exports.resolvePreprocessorConfiguration = resolvePreprocessorConfiguration;
exports.addCucumberPreprocessorPlugin = addCucumberPreprocessorPlugin;
exports.beforeRunHandler = beforeRunHandler;
exports.afterRunHandler = afterRunHandler;
exports.beforeSpecHandler = beforeSpecHandler;
exports.afterSpecHandler = afterSpecHandler;
exports.afterScreenshotHandler = afterScreenshotHandler;
const messages_1 = require("@cucumber/messages");
const tag_expressions_1 = __importDefault(require("@cucumber/tag-expressions"));
const base64_js_1 = require("base64-js");
const error_1 = require("./helpers/error");
const ast_1 = require("./helpers/ast");
const constants_1 = require("./constants");
const cypress_task_definitions_1 = require("./cypress-task-definitions");
const browser_runtime_1 = require("./browser-runtime");
const cypress_1 = require("./helpers/cypress");
const data_table_1 = __importDefault(require("./data_table"));
exports.DataTable = data_table_1.default;
const registry_1 = require("./registry");
function defineStep(description, implementation) {
    (0, registry_1.getRegistry)().defineStep(description, implementation);
}
function runStepDefininition(world, text, argument) {
    cy.then(() => {
        (0, cypress_1.runStepWithLogGroup)({
            keyword: "Step",
            text,
            fn: () => (0, registry_1.getRegistry)().runStepDefininition(world, text, argument),
        });
    });
}
function defineParameterType(options) {
    (0, registry_1.getRegistry)().defineParameterType(options);
}
function defineBefore(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineBefore({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineBefore(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for Before hook");
    }
}
function defineAfter(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineAfter({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineAfter(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for After hook");
    }
}
function defineBeforeStep(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeStep({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeStep(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for BeforeStep hook");
    }
}
function defineAfterStep(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineAfterStep({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineAfterStep(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for AfterStep hook");
    }
}
function defineBeforeAll(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeAll({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeAll(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for BeforeAll hook");
    }
}
function defineAfterAll(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineAfterAll({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineAfterAll(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for AfterAll hook");
    }
}
function createStringAttachment(data, mediaType, encoding) {
    const taskData = {
        data,
        mediaType,
        encoding,
    };
    cy.task(cypress_task_definitions_1.TASK_CREATE_STRING_ATTACHMENT, taskData, {
        log: false,
    });
}
function attach(data, mediaType) {
    if (typeof data === "string") {
        mediaType = mediaType !== null && mediaType !== void 0 ? mediaType : "text/plain";
        if (mediaType.startsWith("base64:")) {
            createStringAttachment(data, mediaType.replace("base64:", ""), messages_1.AttachmentContentEncoding.BASE64);
        }
        else {
            createStringAttachment(data, mediaType !== null && mediaType !== void 0 ? mediaType : "text/plain", messages_1.AttachmentContentEncoding.IDENTITY);
        }
    }
    else if (data instanceof ArrayBuffer) {
        if (typeof mediaType !== "string") {
            throw Error("ArrayBuffer attachments must specify a media type");
        }
        createStringAttachment((0, base64_js_1.fromByteArray)(new Uint8Array(data)), mediaType, messages_1.AttachmentContentEncoding.BASE64);
    }
    else {
        throw Error("Invalid attachment data: must be a ArrayBuffer or string");
    }
}
function isFeature() {
    return Cypress.env(constants_1.INTERNAL_SPEC_PROPERTIES) != null;
}
const NOT_FEATURE_ERROR = "Expected to find internal properties, but didn't. This is likely because you're calling doesFeatureMatch() in a non-feature spec. Use doesFeatureMatch() in combination with isFeature() if you have both feature and non-feature specs";
function doesFeatureMatch(expression) {
    let pickle;
    try {
        pickle = (0, browser_runtime_1.retrieveInternalSpecProperties)().pickle;
    }
    catch (_a) {
        throw (0, error_1.createError)(NOT_FEATURE_ERROR);
    }
    return (0, tag_expressions_1.default)(expression).evaluate((0, ast_1.collectTagNames)(pickle.tags));
}
/**
 * Everything below exist merely for the purpose of being nice with TypeScript. All of these methods
 * are exclusively used in the node environment and the node field in package.json points to
 * ./lib/entrypoint-node.ts.
 */
function createUnimplemented() {
    return new Error("Plugin methods aren't available in a browser environment");
}
function resolvePreprocessorConfiguration(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
cypressConfig, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
environment, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
implicitIntegrationFolder, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
configurationFileResolver) {
    throw createUnimplemented();
}
async function addCucumberPreprocessorPlugin(on, config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
options = {}) {
    throw createUnimplemented();
}
async function beforeRunHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config) {
    throw createUnimplemented();
}
async function afterRunHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config) {
    throw createUnimplemented();
}
async function beforeSpecHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
spec) {
    throw createUnimplemented();
}
async function afterSpecHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
spec, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
results) {
    throw createUnimplemented();
}
async function afterScreenshotHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
details) {
    throw createUnimplemented();
}
